// Code generated by protoc-gen-zeropb. DO NOT EDIT.

package transportzeropb

import "github.com/danhhz/zeropb"

type RaftMsg struct {
  buf []byte
  offsets struct {
    a [3]uint16
    m map[int]uint64
  }
}

var repeatedFields_RaftMsg = zeropb.RepeatedFields{
  2: struct{}{},
}

func (m *RaftMsg) Encode() []byte {
  return m.buf
}

func (m *RaftMsg) Decode(buf []byte) error {
  m.buf = buf
  return zeropb.Decode(m.buf, zeropb.WrapOffsets(m.offsets.a[:], &m.offsets.m), repeatedFields_RaftMsg)
}

func (m *RaftMsg) ResetWithBuf(buf []byte) {
  if len(buf) > 0 {
    panic(`buf must be empty`)
  }
  m.buf = buf
  zeropb.WrapOffsets(m.offsets.a[:], &m.offsets.m).Clear()
}

func (m *RaftMsg) Epoch() int32 {
  return zeropb.GetInt32(m.buf, zeropb.WrapOffsets(m.offsets.a[:], &m.offsets.m), 1)
}

func (m *RaftMsg) SetEpoch(x int32) {
  zeropb.SetInt32(&m.buf, zeropb.WrapOffsets(m.offsets.a[:], &m.offsets.m), 1, x)
}

type RaftMsgMessageIterator []byte

func (i *RaftMsgMessageIterator) Next(m *Message) (bool, error) {
  var buf []byte
  *i, buf = zeropb.FindNextField((*i), 2)
  if buf == nil {
    return false, nil
  }
  return true, m.Decode(buf)
}

func (m *RaftMsg) Msgs() RaftMsgMessageIterator {
  return RaftMsgMessageIterator(zeropb.GetRepeatedNonPacked(m.buf, zeropb.WrapOffsets(m.offsets.a[:], &m.offsets.m), 2))
}

func (m *RaftMsg) AppendToMsgs(x Message) {
  buf := x.Encode()
  zeropb.AppendBytes(&m.buf, zeropb.WrapOffsets(m.offsets.a[:], &m.offsets.m), 2, buf)
}

